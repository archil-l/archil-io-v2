# JWT Authentication Implementation Plan

## Overview

This document outlines the implementation plan for adding JWT-based token authentication to the LLM streaming function. The system will secure the streaming endpoint by requiring valid JWT tokens for access.

## Objectives

1. Create a secure secret storage layer to manage JWT signing keys
2. Implement JWT token generation in the web application
3. Add JWT verification to the LLM streaming function
4. Enable secure communication between the web app and streaming Lambda

## Architecture

### Current State

- WebAppStack: Remix web app + Lambda + CloudFront
- LLMStreamStack: Streaming Lambda with Function URL (no auth)
- Communication: Web app → LLM streaming endpoint (unauthenticated)

### Target State

- **SecretsStack** (NEW): Manages JWT signing secret in AWS Secrets Manager
- **WebAppStack** (MODIFIED): Grants Lambda access to JWT secret, implements token generation
- **LLMStreamStack** (MODIFIED): Grants Lambda access to JWT secret, implements token verification
- **Communication**: Web app includes JWT tokens in requests → Streaming Lambda verifies tokens

## Implementation Phases

### Phase 1: Secret Storage Layer

**File**: `cdk/lib/secrets-stack.ts`

**Purpose**: Create and manage the JWT signing secret securely

**Components**:

- AWS Secrets Manager to store the JWT signing secret
- Secret name: `archil-io-v2-jwt-secret-{stage}`
- Secret value: 256-bit cryptographically secure random key (for HS256 algorithm)
- Export secret ARN for use by other stacks

**Stack Properties**:

```typescript
interface SecretsStackProps extends cdk.StackProps {
  envConfig: EnvironmentConfig;
}
```

**Exported Values**:

- `secretArn`: ARN of the JWT secret for other stacks to reference

---

### Phase 2: Token Generation Service

**File**: `src/app/server/auth/jwt-service.ts`

**Purpose**: Generate and manage JWT tokens in the web app

**Key Details**:

- **Algorithm**: HS256 (HMAC with SHA-256)
- **Token Lifetime**: 1 hour (3600 seconds)
- **Global Token**: Single token generated at startup, reused for all requests
- **Claims**:
  - `iss` (issuer): "archil-io-v2"
  - `iat` (issued at): Current timestamp
  - `exp` (expiration): Current timestamp + 3600 seconds
  - `sub` (subject): "app" (since it's a global app token)

**Implementation**:

```typescript
class JWTService {
  private secret: string;
  private currentToken: string;
  private tokenExpiresAt: number;

  constructor(secret: string);

  // Initialize service and generate initial token
  async initialize(): Promise<void>;

  // Get current valid token, refresh if needed
  getToken(): Promise<string>;

  // Check if token needs refresh (< 5 minutes remaining)
  private needsRefresh(): boolean;

  // Generate a new JWT token
  private generateToken(): string;
}
```

**Features**:

- Lazy initialization: Fetch secret from Secrets Manager on first use
- Token caching: Store in memory to avoid repeated Secrets Manager calls
- Auto-refresh: Automatically refresh token when < 5 minutes remaining

---

### Phase 3: Token Endpoint

**File**: `src/app/routes/api/jwt-token.ts`

**Purpose**: Provide an HTTP endpoint for clients to fetch valid JWT tokens

**Endpoint**: `GET /api/jwt-token`

**Response Format**:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3599,
  "expiresAt": 1708090000
}
```

**Status Codes**:

- `200 OK`: Successfully returned token
- `500 Internal Server Error`: Failed to fetch secret or generate token

**Implementation**:

- Use the JWTService to get a valid token
- Return token with expiry information
- Include CORS headers for cross-origin requests

---

### Phase 4: JWT Verification Service

**File**: `src/app/server/auth/jwt-verifier.ts` (reusable module)

**Purpose**: Verify JWT tokens in the streaming handler

**Functions**:

```typescript
// Verify token signature and expiry
function verifyToken(
  token: string,
  secret: string,
): {
  valid: boolean;
  payload?: JWTPayload;
  error?: string;
};

// Extract token from Authorization header
function extractTokenFromHeader(headers: Record<string, string>): string | null;
```

**Verification Logic**:

1. Extract token from `Authorization: Bearer {token}` header
2. Verify signature using the JWT secret
3. Check if token has expired
4. Return verification result

---

### Phase 5: CDK Stack Updates

#### 5.1 SecretsStack

**File**: `cdk/lib/secrets-stack.ts` (NEW)

```typescript
interface SecretsStackProps extends cdk.StackProps {
  envConfig: EnvironmentConfig;
}

class SecretsStack extends cdk.Stack {
  public readonly jwtSecretArn: string;

  constructor(scope: Construct, id: string, props: SecretsStackProps);
}
```

**Key Resources**:

- `Secret`: Stores the JWT signing key (auto-generated by CDK)
- Exports the secret ARN for other stacks

#### 5.2 WebAppStack Updates

**File**: `cdk/lib/web-app-stack.ts` (MODIFIED)

**Changes**:

1. Add `SecretsStackProps` parameter to constructor
2. Add dependency on SecretsStack
3. Grant Lambda read access to JWT secret
4. Add environment variables:
   - `JWT_SECRET_ARN`: ARN of the JWT secret
   - `JWT_EXPIRY_HOURS`: "1" (hardcoded, for clarity)
5. Update CORS to include `Authorization` header

**Code Changes**:

```typescript
interface WebAppStackProps extends cdk.StackProps {
  envConfig: EnvironmentConfig;
  subdomainStack?: SubdomainStack;
  secretsStack: SecretsStack; // NEW
}

// Grant read access to secret
secretsStack.grantReadSecret(remixFunction);

// Add environment variables
remixFunction.addEnvironment("JWT_SECRET_ARN", secretsStack.jwtSecretArn);
remixFunction.addEnvironment("JWT_EXPIRY_HOURS", "1");
```

#### 5.3 LLMStreamStack Updates

**File**: `cdk/lib/llm-stream-stack.ts` (MODIFIED)

**Changes**:

1. Add `SecretsStackProps` parameter to constructor
2. Add dependency on SecretsStack
3. Grant Lambda read access to JWT secret
4. Add environment variable:
   - `JWT_SECRET_ARN`: ARN of the JWT secret
5. Change Function URL auth type to `AWS_IAM` for explicit auth handling
6. Update CORS to include `Authorization` header

**Code Changes**:

```typescript
interface LLMStreamStackProps extends cdk.StackProps {
  envConfig: EnvironmentConfig;
  secretsStack: SecretsStack; // NEW
}

// Grant read access to secret
secretsStack.grantReadSecret(streamingFunction);

// Add environment variable
streamingFunction.addEnvironment("JWT_SECRET_ARN", secretsStack.jwtSecretArn);

// Function URL already supports Authorization header in CORS
```

#### 5.4 App Configuration

**File**: `cdk/app.ts` (MODIFIED)

**Changes**:

1. Instantiate SecretsStack first
2. Pass it to WebAppStack and LLMStreamStack
3. Set proper stack dependencies

```typescript
// Create Secrets Stack
const secretsStack = new SecretsStack(
  app,
  `archil-io-v2-secrets-${envConfig.stage}`,
  { envConfig },
);

// Pass to other stacks
const webAppStack = new WebAppStack(app, `archil-io-v2-${envConfig.stage}`, {
  envConfig,
  subdomainStack,
  secretsStack,
});

const llmStreamStack = new LLMStreamStack(
  app,
  `archil-io-v2-llm-stream-${envConfig.stage}`,
  { envConfig, secretsStack },
);
```

---

### Phase 6: Streaming Handler Update

**File**: `src/app/server/streaming/streaming-handler.ts` (MODIFIED)

**Changes**:

1. Import JWT verification utilities
2. Add token verification before processing requests
3. Return 401 Unauthorized for invalid/missing tokens
4. Continue with LLM streaming only if token is valid

**Implementation Flow**:

```
1. Receive request
2. Check for Authorization header
3. Extract JWT token
4. Fetch secret from Secrets Manager
5. Verify token signature and expiry
6. If invalid → return 401 error
7. If valid → proceed with LLM streaming
```

**Error Responses**:

- `400 Bad Request`: Missing Authorization header
- `401 Unauthorized`: Invalid or expired token
- `500 Internal Server Error`: Failed to fetch secret or verify token

---

### Phase 7: Client Integration

**File**: `src/app/features/welcome/hooks/use-conversation.ts` (MODIFIED)

**Changes**:

1. Fetch JWT token from `/api/jwt-token` on component mount
2. Store token in a React state/ref
3. Include token in all requests to streaming endpoint
4. Handle 401 responses by refreshing token and retrying

**Implementation Pattern**:

```typescript
// On component mount
const [token, setToken] = useState<string | null>(null);

useEffect(() => {
  const fetchToken = async () => {
    const response = await fetch("/api/jwt-token");
    const data = await response.json();
    setToken(data.token);
  };
  fetchToken();
}, []);

// In request to streaming endpoint
const headers = {
  "Content-Type": "application/json",
  Authorization: `Bearer ${token}`,
};

// Handle 401 and refresh
if (response.status === 401) {
  // Refresh token and retry
}
```

---

### Phase 8: Dependencies

**File**: `package.json` (VERIFY)

**Required Packages**:

- `jsonwebtoken`: For JWT generation and verification (likely already installed)
- `aws-sdk`: For Secrets Manager access (already available in Lambda runtime)

**Install if needed**:

```bash
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken
```

---

## File Summary

### New Files

| File                                        | Purpose                             |
| ------------------------------------------- | ----------------------------------- |
| `cdk/lib/secrets-stack.ts`                  | CDK stack for JWT secret management |
| `src/app/server/auth/jwt-service.ts`        | JWT token generation service        |
| `src/app/server/auth/jwt-verifier.ts`       | JWT token verification utilities    |
| `src/app/routes/api/jwt-token.ts`           | Token endpoint                      |
| `docs/JWT_AUTHENTICATION_IMPLEMENTATION.md` | This implementation plan            |

### Modified Files

| File                                                 | Changes                                               |
| ---------------------------------------------------- | ----------------------------------------------------- |
| `cdk/app.ts`                                         | Add SecretsStack instantiation and dependencies       |
| `cdk/lib/web-app-stack.ts`                           | Grant secret access, add env vars, update auth config |
| `cdk/lib/llm-stream-stack.ts`                        | Grant secret access, add env vars, update CORS        |
| `src/app/server/streaming/streaming-handler.ts`      | Add JWT verification logic                            |
| `src/app/features/welcome/hooks/use-conversation.ts` | Add token fetching and header injection               |
| `package.json`                                       | Add jsonwebtoken dependency if needed                 |

---

## Security Considerations

### Secret Management

- **Storage**: JWT secret encrypted at rest in AWS Secrets Manager
- **Access**: Only granted to necessary Lambda functions via IAM
- **Rotation**: Currently static (can be enhanced later for rotation)

### Token Security

- **Signature**: HS256 with strong secret
- **Expiry**: 1-hour lifetime limits exposure window
- **Transport**: Only over HTTPS (enforced by CloudFront and API Gateway)
- **Header**: Authorization header prevents token leakage in URLs

### Authentication Flow

- **No CORS Preflight Issues**: Token included after OPTIONS request succeeds
- **Stateless**: Each token is self-contained (no session storage needed)
- **Automatic Refresh**: Client-side auto-refresh before expiry

### Limitations

- **Single Global Token**: Not per-user/per-session (simplified approach)
- **No Token Revocation**: Tokens valid until expiry (short 1-hour window mitigates risk)
- **No Rate Limiting**: Consider adding rate limiting if high volume expected

---

## Testing Strategy

### Unit Tests

1. **JWT Service**:
   - Token generation
   - Token refresh logic
   - Secret fetching

2. **JWT Verifier**:
   - Valid token verification
   - Expired token rejection
   - Invalid signature rejection
   - Missing header handling

### Integration Tests

1. **Token Endpoint**: `/api/jwt-token` returns valid token
2. **Streaming with Token**: Request with valid token succeeds
3. **Streaming without Token**: Request without token returns 401
4. **Streaming with Invalid Token**: Request with invalid token returns 401
5. **Token Refresh**: Client handles 401 and fetches new token

### E2E Tests

1. Full conversation flow with automatic token management
2. Token expiry and refresh during long-running streams
3. Recovery from token expiration mid-request

---

## Deployment Considerations

### CDK Deployment Order

1. Deploy SecretsStack first
2. Deploy WebAppStack and LLMStreamStack (can be parallel, both depend on SecretsStack)

### Environment Variables

- `JWT_SECRET_ARN`: Automatically injected by CDK
- `ANTHROPIC_API_KEY`: Already configured
- `NODE_ENV`: Set to "production" in Lambda

### Rollout

- Deploy secrets stack first (no code changes)
- Deploy web app stack (token endpoint added)
- Deploy streaming stack (verification added)
- Deploy client (token fetching added)

### Monitoring

- CloudWatch logs for token verification failures
- Metrics for 401 response rates
- Metrics for token refresh requests

---

## Future Enhancements

1. **Per-User Tokens**: Include user identifier in token claims for audit logging
2. **Token Rotation**: Implement secret rotation strategy
3. **Token Revocation**: Add Redis/DynamoDB for revocation list
4. **Rate Limiting**: Add rate limiting based on token/IP
5. **Audit Logging**: Log all token generation and verification events
6. **Refresh Tokens**: Implement separate long-lived refresh tokens
7. **Asymmetric Signing**: Move from HS256 to RS256 (public/private key pairs)

---

## Migration Checklist

Before going live:

- [ ] Create SecretsStack
- [ ] Update WebAppStack with secret access
- [ ] Update LLMStreamStack with secret access
- [ ] Implement JWT service
- [ ] Implement JWT verifier
- [ ] Create token endpoint
- [ ] Add verification to streaming handler
- [ ] Update client to fetch and include tokens
- [ ] Update CORS configuration
- [ ] Add unit tests for JWT operations
- [ ] Add integration tests for auth flow
- [ ] Test token expiry and refresh
- [ ] Load test with token validation overhead
- [ ] Update API documentation
- [ ] Monitor for 401 errors post-deployment
- [ ] Verify streaming still works correctly

---

## Rollback Plan

If issues arise:

1. **Immediate**: Disable JWT verification (accept all requests)
2. **Short-term**: Revert streaming handler changes
3. **Long-term**: Investigate root cause and redeploy

---

## Documentation

This plan will be implemented in the following order:

1. ✅ Create this plan document
2. Create SecretsStack CDK infrastructure
3. Implement JWT token service
4. Implement JWT verification service
5. Create token endpoint
6. Update streaming handler with verification
7. Update client to include tokens
8. Test end-to-end flow
